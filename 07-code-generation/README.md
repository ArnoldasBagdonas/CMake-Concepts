# Example Project: Code Generation Best Practices

Code generation is a technique that involves automatically generating source code or other artifacts based on predefined templates or rules. This can be a powerful approach to automate repetitive tasks, increase productivity, and maintain consistency in software development.

## Best Practices for Integrating and Managing Code Generation

- **Identify the Use Case**: Before starting with code generation, clearly define the specific use case or problem you want to solve. This could be generating boilerplate code, creating serialization or database access layers, or any other task that can be automated.

- **Choose the Right Tool**: CMake provides various ways to generate code. Some common options include using CMake's own scripting language, writing custom scripts, or using external tools like Python or Perl scripts. Choose a tool that best suits your requirements and familiarity.

- **Separate Generated Code**: It's essential to keep the generated code separate from the rest of your source code to avoid confusion and potential conflicts. Create dedicated directories or namespaces for generated code, and add appropriate rules in your build system to handle generated files separately.

- **Template-Based Code Generation**: Templates provide a flexible and reusable approach for generating code. Define templates that capture the common patterns or structures you want to generate, and use placeholders or variables to customize the generated code based on specific requirements.

- **Parameterize Code Generation**: Make your code generation process customizable by introducing parameters or configuration options. This allows developers to tailor the generated code based on specific needs or variations in the project.

- **Maintain Generated Code**: When code generation is used, it's crucial to establish a clear process for maintaining the generated code. Define how modifications to the generated code will be handled, such as preserving user modifications or updating the generated code when templates change.

- **Automate Code Generation**: Integrate the code generation process into your build system or development workflow. This ensures that the code generation step is automatically triggered when needed, reducing manual effort and potential errors.

- **Test Generated Code**: Just like any other code, the generated code should be thoroughly tested to ensure its correctness and reliability. Create appropriate unit tests or integration tests specifically for the generated code to catch any potential issues.

- **Document Code Generation Process**: Provide clear documentation on how to use and maintain the code generation system. Include instructions for developers on how to modify or extend the generated code and describe the overall process and conventions used.

- **Version Control Generated Files**: Track the generated files in your version control system to ensure reproducibility and traceability. However, avoid committing generated files that frequently change to prevent unnecessary conflicts in your repository.

Remember, code generation can be a powerful tool, but it should be used judiciously. It's important to strike a balance between automation and maintainability, ensuring that the generated code remains understandable and easy to work with.


##  CMakeLists.txt Explanation

The CMakeLists.txt file contains the necessary instructions for CMake to configure and build the project. Here's a breakdown of its contents:

- **Set the minimum version of CMake**: Specifies the minimum version of CMake required to run the CMake script.

- **Set the project name**: Defines the name of the project being built, in this case, "exampleproject," along with its version number.

- **Find Python package**: Searches for the Python package, assuming it is needed for the project.

- **Set variables for the generator script**: Sets up variables to store the names and paths of the generator script and its generated files.

- **Display the command that will be executed**: Outputs a message displaying the command that will be executed to run the generator script with its arguments.

- **Execute the generator script to get dependencies**: Executes the generator script with the specified arguments to obtain a list of dependencies required for the project.

- **Check execution status and display dependencies**: Checks if the execution of the generator script was successful and displays the obtained dependencies.

- **Execute the generator script to get outputs**: Executes the generator script with the specified arguments to obtain a list of outputs generated by the script.

- **Check execution status and display outputs**: Checks if the execution of the generator script was successful and displays the obtained outputs.

- **Create a custom target for the generated outputs**: Creates a custom target named "version" that depends on the generated outputs. This target ensures that the outputs are generated before building the project.

- **Add a custom command for generating outputs**: Adds a custom command that executes the generator script to generate the outputs. This command is associated with the "version" target and will be executed during the build process.

- **Create an executable target for the project**: Creates an executable target for the project, including the main.cpp file and the generated version.cpp file.

- **Include project source directory for header file search**: Specifies the project source directory to be included for header file search, allowing access to project-specific headers.

- **Create a custom target for file touching**: Creates a custom target named "file_toucher" that touches (updates the modification timestamp of) the generated version.cpp file.

- **Add file touching target as a dependency**: Adds the "file_toucher" target as a dependency for the project, ensuring that the version.cpp file is always updated before building the project, even if there are no changes to its content.

Overall, this CMake file sets up the project, executes a generator script to obtain dependencies and outputs, creates custom targets to ensure proper generation and build behavior, and manages dependencies to keep the generated files up-to-date.

## Building the Example

To perform an out-of-source build, follow these steps:

1. Create a new directory for the build process. This directory can be named `build`, `bin`, or any other descriptive name.
2. Navigate to the newly created build directory:
   ```bash
   mkdir build && cd build
   ```
3. Run the CMake command from the build directory, specifying the path to the source code directory. For example:
   ```bash
   cmake ..
   ```
4. CMake will generate the build files (e.g., Makefiles, Visual Studio solution files) in the build directory based on the CMakeLists.txt file in the source code directory.
5. Build the project using the generated build system (e.g., Makefiles):
   ```bash
   cmake --build .
   ```
6. The built binaries and artifacts will be placed in the build directory, keeping them separate from the source code.
7. From the build directory, run the resulting executable:
   ```bash
   ./exampleproject
   ```
You should see the output from the "hello" program.

> **_NOTE:_** It's important to note that the build directory should be excluded from version control systems (e.g., Git) by adding it to the project's .gitignore file. This ensures that the build artifacts are not inadvertently committed to the repository.

## Getting Started

To get started with the examples, follow these steps:

1. Clone this repository: `git clone git@github.com:ArnoldasBagdonas/CMake-Concepts.git`
2. Navigate to the desired example folder: `cd cmake-concepts-examples/<example-folder>`
3. Follow the instructions provided in the example's README to build and run the example.

Make sure you have Docker installed and properly configured on your system.

## Contributing

Contributions to this repository are welcome! If you have additional examples, improvements, or bug fixes, feel free to submit a pull request. Please refer to the CONTRIBUTING.md file for guidelines on contributing.

## License

This repository is licensed under the MIT License. See the LICENSE.md file for more information.
